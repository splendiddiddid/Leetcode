[918. 环形子数组的最大和](https://leetcode.cn/problems/maximum-sum-circular-subarray/description/?envType=study-plan-v2&envId=top-interview-150)

<img width="900" height="541" alt="image" src="https://github.com/user-attachments/assets/b8896752-5a5c-4832-8696-0ca0ab42dbe7" />


这个和53.最大子数组和，多了一点“环形”，即首尾相连，最大子数组可能跨了首尾。因此考虑两种情况：
+ 按照普通数组，直接计算最大子数组和
+ 计算首尾相连的最大子数组
  + 方法1：计算最小子数组和，数组所有元素和allSum是常数，正常段的最小子数组和为ansMin，那么跨首尾的最大子数组和为`allSum - ansMin`
  + 方法2：跨首尾的子数组分成两端，左边一段当成是最大前缀，右边一段看作是最大后缀，遍历所有下标i作为分界，左边的前缀加上右边的后缀，找到和最大的跨首尾的子数组

+ 上面两种子数组，取max即为答案



# 最小子数组和
按照常规数组计算最大子数组的时候，同时计算最小子数组，最终allSum减去ansMin即为跨首尾的最大子数组和——需要注意，如果整个数组全是负数，那么`allSum = ansMin`，最终结果应该是取ansMax。

<img width="301" height="79" alt="image" src="https://github.com/user-attachments/assets/02ef9e86-c93f-4f1a-8938-bce7913ac99a" />

```cpp
class Solution {
public:
    int maxSubarraySumCircular(vector<int>& nums) {
        int n = nums.size();
        int ansMin = nums[0], ansMax = nums[0],allSum = nums[0];
        int curMin = nums[0], curMax = nums[0];
        for(int i = 1; i < n; i++){
            allSum += nums[i];
            // 计算当前元素结尾的最大子数组和
            curMax = curMax > 0 ? curMax + nums[i] : nums[i];
            ansMax = max(curMax, ansMax);
            // 计算当前元素结尾的最小子数组和
            curMin = curMin > 0 ? nums[i] : curMin + nums[i];
            ansMin = min(curMin, ansMin);             
        }
        // 全是负数的话，allSum = ansMin，此时只能取ansMax，正常取二者更大的那个
        return allSum == ansMin ? ansMax : max(ansMax, allSum - ansMin);
        
    }
};
```


# 最大前缀与最大后缀和

<img width="338" height="73" alt="image" src="https://github.com/user-attachments/assets/41393e66-a1fe-4ede-bfb8-42bb9ce59a3c" />
