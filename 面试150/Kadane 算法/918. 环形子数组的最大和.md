[918. 环形子数组的最大和](https://leetcode.cn/problems/maximum-sum-circular-subarray/description/?envType=study-plan-v2&envId=top-interview-150)

<img width="900" height="541" alt="image" src="https://github.com/user-attachments/assets/b8896752-5a5c-4832-8696-0ca0ab42dbe7" />


这个和53.最大子数组和，多了一点“环形”，即首尾相连，最大子数组可能跨了首尾。因此考虑两种情况：
+ 按照普通数组，直接计算最大子数组和
+ 计算首尾相连的最大子数组
  + 方法1：计算最小子数组和，数组所有元素和allSum是常数，正常段的最小子数组和为ansMin，那么跨首尾的最大子数组和为`allSum - ansMin`
  + 方法2：跨首尾的子数组分成两端，左边一段当成是最大前缀，右边一段看作是最大后缀，遍历所有下标i作为分界，左边的前缀加上右边的后缀，找到和最大的跨首尾的子数组

+ 上面两种子数组，取max即为答案



# 最小子数组和
按照常规数组计算最大子数组的时候，同时计算最小子数组，最终allSum减去ansMin即为跨首尾的最大子数组和——需要注意，如果整个数组全是负数，那么`allSum = ansMin`，最终结果应该是取ansMax。

<img width="50%" alt="image" src="https://github.com/user-attachments/assets/02ef9e86-c93f-4f1a-8938-bce7913ac99a" />

```cpp
class Solution {
public:
    int maxSubarraySumCircular(vector<int>& nums) {
        int n = nums.size();
        int ansMin = nums[0], ansMax = nums[0],allSum = nums[0];
        int curMin = nums[0], curMax = nums[0];
        for(int i = 1; i < n; i++){
            allSum += nums[i];
            // 计算当前元素结尾的最大子数组和
            curMax = curMax > 0 ? curMax + nums[i] : nums[i];
            ansMax = max(curMax, ansMax);
            // 计算当前元素结尾的最小子数组和
            curMin = curMin > 0 ? nums[i] : curMin + nums[i];
            ansMin = min(curMin, ansMin);             
        }
        // 全是负数的话，allSum = ansMin，此时只能取ansMax，正常取二者更大的那个
        return allSum == ansMin ? ansMax : max(ansMax, allSum - ansMin);
        
    }
};
```


# 最大前缀与最大后缀和

<img width="338" height="73" alt="image" src="https://github.com/user-attachments/assets/41393e66-a1fe-4ede-bfb8-42bb9ce59a3c" />

<img width="308" height="77" alt="image" src="https://github.com/user-attachments/assets/c5066489-1d41-48da-b2d9-3e88cd50984a" />


分别计算子数组的前缀和后缀，最后二者合起来，就实现了跨首尾的子数组。

```cpp
class Solution {
public:
    int maxSubarraySumCircular(vector<int>& nums) {
        int n = nums.size();
        vector<int> leftmax(n), rightmax(n);
        int ansMax = nums[0], curMax = nums[0], leftsum = nums[0], rightsum = nums[n -1];
        leftmax[0] = nums[0];
        rightmax[n - 1] = nums[n - 1];

        for(int i = 1; i < n - 1 ; i ++){
            // 计算正常数组的最大子数组和
            curMax = curMax > 0 ? curMax + nums[i] : nums[i];
            ansMax = max(ansMax, curMax);

            // 同时计算最大前缀和最大后缀
            leftsum += nums[i];
            rightsum += nums[n-1-i];
            leftmax[i] = max(leftmax[i-1], leftsum);
            rightmax[n -1 -i] = max(rightmax[n -i], rightsum);
        }

        // 上面忽略了最后一个元素
        if(n > 1)
            curMax = curMax > 0 ? curMax + nums[n - 1] : nums[n -1];
            ansMax = max(ansMax, curMax);

        // 以所有下标作为分界，计算左右前缀和后缀组成的跨首尾子数组的和，并更新最大和
        for(int j = 0; j < n - 1; j++){
            ansMax = max(ansMax, leftmax[j] + rightmax[j + 1]);
        }
        return ansMax;
    }
};
```

官方题解用的最大前缀和右边剩下的元素的和，其实道理一样的。甚至还能用最大后缀加上左边全部元素的和。 因为看到某一段的和其实是小于等于最大前后缀和的。

下面是官方题解，用的最大前缀和 加 后面一截全部元素的和。

```cpp
// 最大前缀 + 后缀和
class Solution {
public:
    int maxSubarraySumCircular(vector<int>& nums) {
        int n = nums.size();
        vector<int> leftMax(n);
        // 对坐标为 0 处的元素单独处理，避免考虑子数组为空的情况
        leftMax[0] = nums[0];
        int leftSum = nums[0];
        int pre = nums[0];
        int res = nums[0];
        for (int i = 1; i < n; i++) {
            pre = max(pre + nums[i], nums[i]);
            res = max(res, pre);
            leftSum += nums[i];
            leftMax[i] = max(leftMax[i - 1], leftSum);
        }

        // 从右到左枚举后缀，固定后缀，选择最大前缀
        int rightSum = 0;
        for (int i = n - 1; i > 0; i--) {
            rightSum += nums[i];
            res = max(res, rightSum + leftMax[i - 1]);
        }
        return res;
    }
};
```

