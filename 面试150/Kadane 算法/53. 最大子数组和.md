[53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-interview-150)

<img width="755" height="639" alt="image" src="https://github.com/user-attachments/assets/555e086f-e920-4035-8506-b40472341d0b" />

最简单的办法，**暴力求解**，双层循环，外层是子数组的`eftIndex`，内层是子数组的`rightIndex`，时间复杂度是O(n/^2)；

最高效的办法，**动态规划**，只需要遍历一次数组，针对每个元素，更新以`nums[i]`结尾的最大子数组和【局部最优解`curMax[i]`】，当遍历完数组后，所有局部最优中的最大即为答案。
由于`curMax[i]`只跟`curMax[i-1]`和`nums[i]`相关，因此可以简化成只用一个变量`curMax`记录局部最优解（同时更新全局最优解），时间复杂度是O(n)，空间复杂度O(1)。

对于动态查询而言，即查询任意区间`[l,r]`的最大子数组和，使用**线段树**能够高效实现。线段树采用分治思想，将数组逐步拆分，直到只包含一个元素，再上升合并，得到答案。由于拆分、合并需要使用递归，递归栈的空间复杂度O(logN)。

<img width="555" height="200" alt="image" src="https://github.com/user-attachments/assets/8c907404-7c44-4e3c-9847-633bdadca026" />

# 动态规划——Kadane算法
专门针对求**最大子数组和**的动态规划求解方法，就是Kadane算法了。

动态规划关注的点：
+ 定义状态
  假设用curMax数组来协助完成动态规划，`curMax[i]`表示下标`0~i`这段子数组中，以`nums[i]`结尾的最大子数组和，即相当于最大后缀和（自己瞎想的名字），到了`i = n - 1`的时候，就相当于分别找到了以`n`个元素作为结尾的最大子数组的情况。
+ 状态转移方程
  因为一定要以第`i`个元素作为结尾（即后缀），那么`curMax[i]` 就取决于以`nums[i-1]`这个元素结尾的最大子数组和，即`curMax[i-1]`,是否大于0。如果大于0，那么` curMax[i] = curMax[i - 1] + nums[1]`， 否则 `Max[i] = nums[i]`。

  简化为：`curMax[i] = max(curMax[i-1] + nums[i], nums[i])`

+ 初始化和边界条件
  初始化`curMax[0] = nums[0]`

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int n = nums.size();
        int curMax = nums[0];
        int ansMax = nums[0];
        for(int i = 1; i < n; i++){
            curMax = max(curMax + nums[i], nums[i]);
            // curMax = curMax > 0 ? curMax + nums[i] : nums[i];
            ansMax = max(ansMax, curMax);
        }
        return ansMax;
        
    }
};
```

哈哈哈哈哈上面是从左往右的，当成是以元素 `nums[i]`结束的所有最大后缀，也可能换成是从右往左的，那么就是以`nums[i]`元素为开头的所有最大前缀了…………差不多的哈哈哈哈

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int n = nums.size();
        int ansMax = nums[n - 1];
        int curMax = nums[n - 1];
        // 从右往走，找所有最大前缀中的最大
        for(int i = n - 2; i >= 0; i--){
            curMax = curMax > 0 ? curMax + nums[i] : nums[i];
            ansMax = max(ansMax, curMax);
        }
        return ansMax;
    }
};
```

# 分治——线段树
[线段树基础](https://oi-wiki.org/ds/seg/)

线段树，可以说是一种数据结构，将数组分成段表示，每个节点（每个段）根据实际需要定义一些状态（参数）。 构造线段树需要用到递归，一直分割直到一个段只有一个元素了。

根据我们求最大子数组和的题目要求，我们需要对一个节点定义一下几个参数：
+ 当前段的最大子数组和 `maxSubSum`
+ 当前段的最大前缀和  `lSum`
+ 当前段的最大后缀和  `rSum`
+ 当前段的元素和  `allSum`

合并区间`[l, m]`（left区间）和`[m+1,r]`（right区间）的时候，需要使用left区间和right区间的参数来更新完整区间`[l,r]`的参数。
+ 整个区间元素，直接等于left和right两个区间的所有元素和 `left.allSum + right.allSum`
+ 最大前缀和 是以下两种情况更大那个：
  + 左边区间全部元素加上右边区间的最大前缀和
  + 左边区间的最大前缀和
  + `max(left.lSum, left.allSum + right.lSum)`
+ 同理，最大后缀是 以下两种情况更大那个：
  + 左边区间最大后缀加上右边区间全部元素
  + 右边区间的最大后缀和
  + `max(right.rSum, left.rSum + right.allSum)`
+ 整个区间的最大子数组和考虑两种情况
  + 跨了left和right两个区间，那么只能是left的后缀加上right的前缀，即`left.rSum + right.lSum`
  + 没有跨left和right，那么就来自left 或者right，且是各自区间内的最大子数组和，即`max(left.maxSubSum, right.maxSubSum)`
  + 两种情况取更大那个
 
```cpp


class Solution {
public:
    // 首先用结构体，定义一个区间的四个参数
    struct Status{
        int lSum, rSum, allSum, maxSubSum;
    };

    // 合并区间，计算合并后区间的四个参数
    Status mergeUp(Status left, Status right){
        int allSum = left.allSum + right.allSum;
        int lSum = max(left.allSum + right.lSum, left.lSum);
        int rSum = max(right.allSum + left.rSum, right.rSum);
        int maxSubSum = max(max(left.maxSubSum, right.maxSubSum), left.rSum + right.lSum);
        return (Status){lSum, rSum, allSum, maxSubSum};
    }
    
    // 递归 先拆再合
    Status get(vector<int> &arr, int left, int right){
        // 只剩下一个元素时，返回一个区间
        if(left == right)
            return (Status){arr[left], arr[left], arr[left], arr[left]};
        // 差分区间，计算各区间的参数
        int mid = (left + right) >> 1;
        Status lSub = get(arr, left, mid);
        Status rSub = get(arr, mid + 1, right);
        // 合并区间
        return mergeUp(lSub, rSub);
    }

    int maxSubArray(vector<int>& nums) {
        return get(nums, 0, nums.size() - 1).maxSubSum;
    }
};
```

注意：位算法`mid = (left + right) >> 1`比除法` mid = (left + right) / 2 `效率更高。

使用线段树，虽然时间复杂度和空间复杂度都上去了，但是它可以支持动态查询，查询任意`leftIndex  ~  rightIndex`区间内的最大子数组和，只需要用`get(array, leftIndex, rightIndex)`查询即可。
