[53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-interview-150)

<img width="755" height="639" alt="image" src="https://github.com/user-attachments/assets/555e086f-e920-4035-8506-b40472341d0b" />

最简单的办法，**暴力求解**，双层循环，外层是子数组的`eftIndex`，内层是子数组的`rightIndex`，时间复杂度是O(n/^2)；
最高效的办法，**动态规划**，只需要遍历一次数组，针对每个元素，更新以`nums[i]`结尾的最大子数组和【局部最优解`curMax[i]`】，当遍历完数组后，所有局部最优中的最大即为解决。
由于`curMax[i]`只跟`curMax[i-1]`和`nums[i]`相关，因此可以简化成只用一个变量`curMax`记录局部最优解（同时更新全局最优解），时间复杂度是O(n)，空间复杂度O(1)。
对于动态查询而言，即查询任意区间`[l,r]`的最大子数组和，使用**线段树**能够高效实现。线段树采用分治思想，将数组逐步拆分，直到只包含一个元素，再上升合并，得到答案。由于拆分、合并需要使用递归，递归栈的空间复杂度O(logN)。
<img width="555" height="200" alt="image" src="https://github.com/user-attachments/assets/8c907404-7c44-4e3c-9847-633bdadca026" />

# 动态规划——Kadane算法
专门针对求**最大子数组和**的动态规划求解方法，就是Kadane算法了。

动态规划关注的点：
+ 定义状态
  假设用curMax数组来协助完成动态规划，`curMax[i]`表示下标`0~i`这段子数组中，以`nums[i]`结尾的最大子数组和，即相当于最大后缀和（自己瞎想的名字），到了`i = n - 1`的时候，就相当于分别找到了以`n`个元素作为结尾的最大子数组的情况。
+ 状态转移方程
  因为一定要以第`i`个元素作为结尾（即后缀），那么`curMax[i]` 就取决于以`nums[i-1]`这个元素结尾的最大子数组和，即`curMax[i-1]`,是否大于0。如果大于0，那么` curMax[i] = curMax[i - 1] + nums[1]`， 否则 `Max[i] = nums[i]`。

  简化为：`curMax[i] = max(curMax[i-1] + nums[i], nums[i])`

+ 初始化和边界条件
  初始化`curMax[0] = nums[0]`

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int n = nums.size();
        int curMax = nums[0];
        int ansMax = nums[0];
        for(int i = 1; i < n; i++){
            curMax = max(curMax + nums[i], nums[i]);
            // curMax = curMax > 0 ? curMax + nums[i] : nums[i];
            ansMax = max(ansMax, curMax);
        }
        return ansMax;
        
    }
};

```


# 分治——线段树
