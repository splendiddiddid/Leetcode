[209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/description/?envType=study-plan-v2&envId=top-interview-150)

<img width="907" height="443" alt="image" src="https://github.com/user-attachments/assets/dd505239-05c8-4a1b-9604-23cd59f1590c" />

哈哈哈这个题目和经典，可以用最简单的——暴力求解，直接双层循环，遍历所有可能的子数组，计算和判断和target的关系同时记录子数组长度——会超时，时间复杂度O(n^2)。

# 前缀和 + 二分查找
暴力求解中，一开始已经计算了`[a_i ~ a_j]`区间的和，后面重新确定区间起点为`a_i+1`又会计算`[a_i+1 ~ a_j]`这个区间，重复计算导致时间复杂度上升。我们可能考虑一次遍历的时候，计算所有的**前缀和**——`sum[i]`即表示下标`[0~i]`区间元素的和，这样区间`[a_i ~ a_j]`的和只需要用`m[j] - sum[i-1]`计算得到，而不需要再遍历区间求和——即**所有的子区间，均可以用两段前缀相减得到**。

解决了重复计算的问题，现在需要查找最短子数组，关于查找——可以想到二分查找，将时间复杂度降低到O(logn)，再结合每个start下标，因此整体时间复杂度是O(nlogn)。

```cpp
// 前缀和+二分查找
class Solution {
public:     
    int minSubArrayLen(int target, vector<int>& nums) {
        // 计算前缀和
        int n = nums.size();
        vector<int> sum(n + 1, 0);
        sum[0] = 0;
        for(int i = 0; i < n; i++){
            sum[i + 1] = sum[i] + nums[i];
        }
        int ans = INT_MAX;
        for(int start = 0; start < n ; start++){
            // sum[start] 是0 ~ start-1 这些元素之和  
            int temp = target + sum[start];     
            int left = start + 1, right = n;
            while(left <= right){
                int mid = (left + right) >> 1;
                if(sum[mid] >= temp)
                    right = mid - 1;
                else    
                    left = mid + 1;
            }
            // left 是sum中的下标，表示0 ~ left - 1的元素和
            if(left <= n)
                ans = min(ans, left - start);
        }
        return ans == INT_MAX ? 0 : ans;
    }
};

```


# 滑动窗口
 使用滑动窗口维护一个区间，右边指针right往窗口内加元素，使得窗口满足要求（比如这个题目的，窗口内元素和>= target），左边指针left缩小窗口， 以找到最小的能满足要求的窗口。左右指针不断移动，即窗口滑动，直到遍历完整个数组。 因为只有左右两个指针在遍历数组，因此时间复杂度是O(n)。

具体过程如下：
+ 初始化left、right指针均为0，统计窗口内元素和的sum变量也为0；
+ right指针遍历数组，逐步扩大窗口
+ 如果窗口内元素和＞= target，使left指针右移，尝试缩小窗口——更新满足条件的最小窗口长度
+ 直到遍历完数组

```cpp
class Solution {
public:
      
    int minSubArrayLen(int target, vector<int>& nums) {
        int len = nums.size();
        if(len == 0)
            return 0;
        int sum = 0;
        int left = 0, right = 0;
        int ans = INT_MAX;
        // 遍历数组
        while(right < len){
            // right指针扩大窗口
            sum += nums[right];
            // left指针缩小窗口
            while(sum >= target){
                ans = min(ans, right - left + 1);
                sum -= nums[left];
                left++;
            }
            right++;
        }  
        return ans == INT_MAX ? 0 : ans;  
    }
};
```
