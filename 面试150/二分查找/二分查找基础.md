二分查找是针对有序数组的查找问题的一种优化。正常查找可以想到直接遍历整个数组，时间复杂度是O(n)。对有序数组进行分治，每次查找都将查找区间一分为二，一个数组可以分logn次，查找也就进行logn次，因此时间复杂度是O(logn)。

以下是一些代码模板：
# 左闭右闭
## 查找相等

```cpp
// 返回目标值的索引，如果不存在返回-1
int findEqual(vector<int>& nums, int target) {
    int left = 0, right = nums.size() - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            // 直接返回结果
            return mid;  
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return -1;
}
```

## 查找 >=
使用result记录，记录第一个>= target的

```cpp
// 返回第一个大于等于target的元素的索引
int findFirstGreaterOrEqual(vector<int>& nums, int target) {
    int left = 0, right = nums.size() - 1;
    int result = nums.size(); // 如果没有找到，返回数组长度
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] >= target) {
            result = mid;    // 记录候选位置
            right = mid - 1; // 继续向左寻找更早的满足条件的位置
        } else {
            left = mid + 1;  // 向右搜索
        }
    }
    return result;
}

```

不用其他变量，那么将使用**left**来表示

```cpp
int findFirstGreaterOrEqual(vector<int>& nums, int target) {
    int left = 0, right = nums.size() - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] >= target) {
            right = mid - 1; // 继续向左寻找
        } else {
            left = mid + 1;
        }
    }
    // 循环结束后，left指向第一个>=target的位置
    return left < nums.size() ? left : -1;
}

```

## 查找 >
使用result记录，记录第一个> target的

```cpp
// 返回第一个大于target的元素的索引
int findFirstGreater(vector<int>& nums, int target) {
    int left = 0, right = nums.size() - 1;
    int result = nums.size();
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] > target) {
            result = mid;
            right = mid - 1; // 继续向左寻找
        } else {
            left = mid + 1;  // 向右搜索
        }
    }
    return result;
}

```

不用其他变量，那么将使用**left**来表示

```cpp
int findFirstGreater(vector<int>& nums, int target) {
    int left = 0, right = nums.size() - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] > target) {
            right = mid - 1; // 继续向左寻找
        } else {
            left = mid + 1;
        }
    }
    // 循环结束后，left指向第一个>target的位置
    return left < nums.size() ? left : -1;
}
```


## 查找 <=
使用result记录，记录第一个> target的

```cpp
// 返回最后一个小于等于target的元素的索引
int findLastLessOrEqual(vector<int>& nums, int target) {
    int left = 0, right = nums.size() - 1;
    int result = -1; // 如果没有找到，返回-1
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] <= target) {
            result = mid;    // 记录候选位置
            left = mid + 1;  // 继续向右寻找更大的满足条件的位置
        } else {
            right = mid - 1; // 向左搜索
        }
    }
    return result;
}

```

不用其他变量，那么将使用**right**来表示

```cpp
int findLastLessOrEqual(vector<int>& nums, int target) {
    int left = 0, right = nums.size() - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] <= target) {
            left = mid + 1; // 继续向右寻找
        } else {
            right = mid - 1;
        }
    }
    // 循环结束后，right指向最后一个<=target的位置
    return right >= 0 ? right : -1;
}
```


## 查找 <

使用result记录，记录第一个> target的

```cpp
// 返回最后一个小于target的元素的索引
int findLastLess(vector<int>& nums, int target) {
    int left = 0, right = nums.size() - 1;
    int result = -1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            result = mid;
            left = mid + 1;  // 继续向右寻找
        } else {
            right = mid - 1; // 向左搜索
        }
    }
    return result;
}

```

不用其他变量，那么将使用**right**来表示

```cpp
int findLastLess(vector<int>& nums, int target) {
    int left = 0, right = nums.size() - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1; // 继续向右寻找
        } else {
            right = mid - 1;
        }
    }
    // 循环结束后，right指向最后一个<target的位置
    return right >= 0 ? right : -1;
}
```

# 左闭右开
**查找结束，left、right指向的是>=target的位置。**
## 查找相等

```cpp
int binarySearch(vector<int>& nums, int target) {
    int left = 0;
    int right = nums.size(); // 注意：right 初始化为 n，不可访问
    
    while (left < right) {   // 注意：条件是 <，不是 <=
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] < target) {
            left = mid + 1;  // [mid + 1, right)
        } else {
            right = mid;     // [left, mid) 注意这里不是 mid - 1
        }
    }
    return -1;
}
```

## 查找 >=

```cpp
int findFirstGreaterOrEqual(vector<int>& nums, int target) {
    int left = 0, right = nums.size();
    
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] >= target) {
            right = mid;     // [left, mid)
        } else {
            left = mid + 1;  // [mid + 1, right)
        }
    }
    // 循环结束后，left == right，指向第一个>=target的位置
    return left;
}
```

## 查找 >

```cpp
int findFirstGreater(vector<int>& nums, int target) {
    int left = 0, right = nums.size();
    
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] > target) {
            right = mid;     // [left, mid)
        } else {
            left = mid + 1;  // [mid + 1, right)
        }
    }
    return left;
}
```

## 查找 <=

```cpp
int findLastLessOrEqual(vector<int>& nums, int target) {
    int left = 0, right = nums.size();
    
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] <= target) {
            left = mid + 1;  // [mid + 1, right)
        } else {
            right = mid;     // [left, mid)
        }
    }
    // 循环结束后，left-1 指向最后一个<=target的位置
    return left - 1;
}
```


## 查找 <

```cpp
int findLastLess(vector<int>& nums, int target) {
    int left = 0, right = nums.size();
    
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;  // [mid + 1, right)
        } else {
            right = mid;     // [left, mid)
        }
    }
    return left - 1;
}
```
