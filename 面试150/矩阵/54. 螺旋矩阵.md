[54. 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/description/?envType=study-plan-v2&envId=top-interview-150)
> 给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。
<img width="700"  alt="image" src="https://github.com/user-attachments/assets/c1aed98e-4c3f-45ba-8eff-42ce4618aff8" />

# 模拟
这个是参考的[官方题解](https://leetcode.cn/problems/spiral-matrix/solutions/275393/luo-xuan-ju-zhen-by-leetcode-solution/?envType=study-plan-v2&envId=top-interview-150) ，不是很懂这个题解的意义…… 
+ 需要用到一个同matrix一样大小的vector来保存matrix[i][j]的访问状态
+ 用`int directions[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};`来模拟四个方向的遍历，向右列逐渐+1， 向下行+1，向左列-1，向上行-1
+ 根据行列是否越界or对应位置是否已经访问，来判断是否需要换方向遍历

```cpp
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        // 四个方向，上（向右移动），右（向下移动），下（向左移动），左（向上移动）
        int directions[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        int row = matrix.size(), col = matrix[0].size();
        vector<vector<int>> visited (row, vector<int>(col));
        int total = row * col;
        vector<int> ans (total);
        int r = 0, c = 0;
        int directIndex = 0;
        for(int i = 0; i < total; i++){
            ans[i]= matrix[r][c];
            visited[r][c] = true;
            // 判断下一个位置是否越界or可访问
            int nextRow = r + directions[directIndex][0];
            int nextCol = c + directions[directIndex][1];
            if(nextCol < 0 || nextCol >= col || nextRow < 0 || nextRow >= row || visited[nextRow][nextCol]){
                // 一个方向访问完开始下一个方向
                directIndex = (directIndex + 1) % 4;
            }
            // 下一个可访问的坐标
            r += directions[directIndex][0];
            c += directions[directIndex][1];
        }
        return ans;
    }
};

```

优化，由于题目给了限制`-100 <= matrix[i][j] <= 100`，因此可以**原地修改matrix来表示对应位置是否已访问** —— 访问过修改为`101`，≤100即未访问。
```cpp
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        // 四个方向，上（向右移动），右（向下移动），下（向左移动），左（向上移动）
        int directions[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        int row = matrix.size(), col = matrix[0].size();
        int total = row * col;
        vector<int> ans (total);
        int r = 0, c = 0;
        int directIndex = 0;
        for(int i = 0; i < total; i++){
            ans[i]= matrix[r][c];
            // 原地更改数组 标记已访问
            matrix[r][c] = 101;
            // 判断下一个位置是否越界or可访问
            int nextRow = r + directions[directIndex][0];
            int nextCol = c + directions[directIndex][1];
            if(nextCol < 0 || nextCol >= col || nextRow < 0 || nextRow >= row || matrix[nextRow][nextCol] == 101){
                // 一个方向访问完开始下一个方向
                directIndex = (directIndex + 1) % 4;
            }
            // 下一个可访问的坐标
            r += directions[directIndex][0];
            c += directions[directIndex][1];
        }
        return ans;
    }
};

```


# 按层模拟
## left-right top-bottom 四个变量
left和right表示左右的列，top和bottom表示上下的行，初始化left和top为0，初始化right为col-1，初始化bottom为row-1，遍历完对应的行列后，left和top+1，right和bottom-1，边界条件为`left < right, bottom < top`；

注意，由于访问顺序是这样的，即**每行、每列的末端留给下一个方向**，因此会疏忽`left == right`或者`top == bottom`的情况（只剩一列or只剩一行），需要单独处理这种情况：

<img width="340" alt="image" src="https://github.com/user-attachments/assets/9fdb70cb-fced-4c2d-b534-625785d7b929" />

```cpp
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        int row = matrix.size();
        int col = matrix[0].size();
        vector<int> ans;
        int left = 0, top = 0, right = col - 1, bottom = row - 1;
        while(left < right && top < bottom){
            // 上边的行
            for(int j = left; j < right; j++)
                ans.push_back(matrix[top][j]);
            // 右边的列
            for(int i = top; i < bottom; i++)
                ans.push_back(matrix[i][right]);
            //下面的行
            for(int j = right; j > left; j--)
                ans.push_back(matrix[bottom][j]);
            // 左边的列
            for(int i = bottom; i > top; i--)
                ans.push_back(matrix[i][left]);
            // 遍历后的行列移动        
            left++;
            right--;
            top++;
            bottom--;
        }
        // 单独处理列
        if(left == right)
            for(int i = top; i <= bottom; i++)
                ans.push_back(matrix[i][left]);
        // 单独处理行
        else if(top == bottom)
            for(int j = left; j <= right; j++)
                ans.push_back(matrix[top][j]);
        return ans;
    }
};
```
如果按照官方题解的遍历方式，便不需要单独处理一行一列，但是需要判断**不要重复遍历**。

<img width="800"  alt="image" src="https://github.com/user-attachments/assets/85995a00-a930-4169-a9ed-98a5060b1a46" />


```cpp
 while (left <= right && top <= bottom) {
            for (int column = left; column <= right; column++) {
                order.push_back(matrix[top][column]);
            }
            for (int row = top + 1; row <= bottom; row++) {
                order.push_back(matrix[row][right]);
            }
            if (left < right && top < bottom) {
                for (int column = right - 1; column > left; column--) {
                    order.push_back(matrix[bottom][column]);
                }
                for (int row = bottom; row > top; row--) {
                    order.push_back(matrix[row][left]);
                }
            }
            left++;
            right--;
            top++;
            bottom--;
        }
```
## 不需要额外变量
每遍历一圈（一层），消耗两列和两行，因此遍历的圈数，取决于行列中更小的那个——首先判断col 和 row 哪个小，用`min / 2`表示循环遍历的圈数，每一圈的顺序是上、右、下、左：

<img width="340" alt="image" src="https://github.com/user-attachments/assets/9fdb70cb-fced-4c2d-b534-625785d7b929" />

还需要考虑min的奇偶，如果是偶数，那么直接遍历完，如果是奇数，将剩下一行 or 一列：
+ col小且为奇数，将剩下一列
+ row小且为奇数，将剩下一行

```cpp
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        int row = matrix.size();
        int col = matrix[0].size(); 
        vector<int> ans;

        int num = 0; 
        int flag = 0; 
        // row小且row是偶数为0， row小且row是奇数为1，col小且为偶数为2，col小且为奇数为3
        if(row > col){
            num = col / 2;
            flag = col % 2 == 0 ? 2 : 3;
        }
        else{
            num = row / 2;
            flag = row % 2 == 0 ? 0 : 1;
        }

        for(int i = 0; i < num; i++){
            // 上面的行 行固定为 i 
            for(int j = i; j < col - 1 - i; j++)
                ans.push_back(matrix[i][j]);
            // 右边的列 列固定为col - 1 - i
            for(int j = i; j < row - 1 - i; j++)
                ans.push_back(matrix[j][col - 1 - i]);
            // 下面的行 行固定为row - 1 - i
            for(int j = col- 1- i; j > i ; j --)
                ans.push_back(matrix[row -1 -i][j]);
            // 左边的列 列固定为i
            for(int j = row - 1 - i; j > i; j --)
                ans.push_back(matrix[j][i]);
        }
        // 单独处理一行
        if(flag == 1){
            for(int j = num; j <= col - 1 - num; j++)
                ans.push_back(matrix[num][j]);
        }
        // 单独处理一列
        if(flag == 3){
            for(int j = num; j <= row - 1 - num; j++)
                ans.push_back(matrix[j][num]);
        }
        return ans;
    }
};
```
