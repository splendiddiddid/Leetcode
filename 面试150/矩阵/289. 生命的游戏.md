[289. 生命的游戏](https://leetcode.cn/problems/game-of-life/description/?envType=study-plan-v2&envId=top-interview-150)

<img width="921" height="801" alt="image" src="https://github.com/user-attachments/assets/a67421e4-5acf-4771-a3ed-543f400282bb" />

根据题意，最重要的一点是，
<mark><strong>只定义0/1两种状态下，不能原地修改矩阵</strong></mark>
。因为所有格子内的细胞是同时更新的，且仅依赖上一个状态下紧邻格子的细胞死活情况。 如果原地修改矩阵，先遍历的格子更新后会影响后续遍历格子周围活细胞的数量。

# 空间复杂度O(mn)
+ 申请额外的空间，统计每个格子四周活细胞数量
  + 第一遍遍历细胞格子，统计每个细胞周围八个格子：`[i-1][j] // [i+1][j] // [i][j-1] // [i][j+1] //[i-1][j-1] // [i+1][j-1] // [i-1][j+1]  // [i+1][j+1] `活细胞的数量；
  + 第二遍遍历细胞格子，根据周围活细胞数量，按照题目的规则，更细细胞状态
 
```cpp
// 统计一个细胞四周的活细胞数量
// 根据细胞本身的状态+四周活细胞的数量，判断该细胞状态是否更新
class Solution {
public:
    void gameOfLife(vector<vector<int>>& board) {
        int col = board[0].size();
        int row = board.size();
        vector<vector<int>> status(row, vector<int>(col, 0));
        
        // 统计状态
        for(int i = 0; i < row; i++){
            for(int j = 0; j < col; j++){
                if(board[i][j]){
                    if(j != 0)
                        status[i][j-1]++;
                    if(j != col - 1)
                        status[i][j+1]++;
                    if(i + 1 < row){
                        status[i+1][j]++;
                        if(j != 0)
                            status[i+1][j - 1]++;
                        if(j != col - 1)
                            status[i+1][j+1]++;
                    }
                    if(i != 0){
                        status[i-1][j]++;
                        if(j != 0)
                            status[i-1][j - 1]++;
                        if(j != col - 1)
                            status[i-1][j+1]++;                        
                    }
                }
            }
        }
        for(int i = 0; i < row; i++){
            for(int j = 0; j < col; j++){
                if(board[i][j]){
                    if(status[i][j] < 2 || status[i][j] > 3)
                        board[i][j] = 0;
                }else{
                    if(status[i][j] == 3)
                        board[i][j] = 1;
                }
            }
        }        
    }
};

```
  
+ 复制原矩阵，保留上一状态副本
  




# 优化：空间复杂度O(1)

