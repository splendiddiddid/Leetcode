[289. 生命的游戏](https://leetcode.cn/problems/game-of-life/description/?envType=study-plan-v2&envId=top-interview-150)

<img width="921" height="801" alt="image" src="https://github.com/user-attachments/assets/a67421e4-5acf-4771-a3ed-543f400282bb" />

根据题意，最重要的一点是，
<mark><strong>只定义0/1两种状态下，不能原地修改矩阵</strong></mark>
。因为所有格子内的细胞是同时更新的，且仅依赖上一个状态下紧邻格子的细胞死活情况。 如果原地修改矩阵，先遍历的格子更新后会影响后续遍历格子周围活细胞的数量。

# 空间复杂度O(mn)
+ 申请额外的空间，统计每个格子四周活细胞数量
  + 第一遍遍历细胞格子，统计每个细胞周围八个格子：`[i-1][j] // [i+1][j] // [i][j-1] // [i][j+1] //[i-1][j-1] // [i+1][j-1] // [i-1][j+1]  // [i+1][j+1] `活细胞的数量；
  + 第二遍遍历细胞格子，根据周围活细胞数量，按照题目的规则，更细细胞状态
 
```cpp
// 统计一个细胞四周的活细胞数量
// 根据细胞本身的状态+四周活细胞的数量，判断该细胞状态是否更新
class Solution {
public:
    void gameOfLife(vector<vector<int>>& board) {
        int col = board[0].size();
        int row = board.size();
        vector<vector<int>> status(row, vector<int>(col, 0));
        
        // 统计状态
        for(int i = 0; i < row; i++){
            for(int j = 0; j < col; j++){
                if(board[i][j]){
                    if(j != 0)
                        status[i][j-1]++;
                    if(j != col - 1)
                        status[i][j+1]++;
                    if(i + 1 < row){
                        status[i+1][j]++;
                        if(j != 0)
                            status[i+1][j - 1]++;
                        if(j != col - 1)
                            status[i+1][j+1]++;
                    }
                    if(i != 0){
                        status[i-1][j]++;
                        if(j != 0)
                            status[i-1][j - 1]++;
                        if(j != col - 1)
                            status[i-1][j+1]++;                        
                    }
                }
            }
        }
        for(int i = 0; i < row; i++){
            for(int j = 0; j < col; j++){
                if(board[i][j]){
                    if(status[i][j] < 2 || status[i][j] > 3)
                        board[i][j] = 0;
                }else{
                    if(status[i][j] == 3)
                        board[i][j] = 1;
                }
            }
        }        
    }
};

```
  
+ 复制原矩阵，保留上一状态副本
  + 复制原矩阵，即保留正确的上一状态副本。遍历board的时候，直接更新即可。
  + 注意近邻的8个矩阵的坐标可以用`i + { -1, 0 , 1}`、`j + { -1, 0 , 1}`来表示，即加上数组`{-1, 0 ,1}`，也可以用二维的`{{-1,-1}, {-1,0}, {-1,1}, {0,-1}, {0,1}, {1,-1}, {1,0}, {1,1}}`表示
 
```cpp
// 复制原格子，保存上一状态
class Solution {
public:
    void gameOfLife(vector<vector<int>>& board) {
        vector<vector<int>> old_status = board;
        int col = board[0].size();
        int row = board.size();
        int neig[3] = {-1,0,1};
        for(int i = 0; i < row; i++){
            for(int j = 0; j < col; j++){
                // 统计近邻的8个格子的活细胞数量
                // 使用board[i][j]本身作为统计变量
                board[i][j] = 0;
                for(int m = 0; m <3; m++){
                    for(int n = 0; n < 3; n++){
                        // 排除格子本身[i][j]
                        if(neig[m] != 0 || neig[n] != 0){
                            int r = i + neig[m];
                            int c = j + neig[n];
                            if(r < row && r >= 0 && c >= 0 && c < col && old_status[r][c] == 1)
                                board[i][j]++;
                        }
                    }
                }

                if(old_status[i][j] == 1)
                    if( board[i][j] < 2 || board[i][j] > 3)
                        board[i][j] = 0;
                    else
                        board[i][j] = 1;
                else {
                    if(board[i][j] == 3)
                        board[i][j] = 1;
                    else    
                        board[i][j] = 0;
                }
            }
        }
    }
};
```

# 优化：空间复杂度O(1)
上述需要使用额外m*n空间的原因————board原地更新的话，会影响后续格子的“上一状态”。  那么是否可以**定义其他的状态值**，来标识“之前是活的 现在死亡”和“之前是死亡的 现在复活了”？？

两种变化情况：
+ 之前是活的（1），现在死了————用-1表示；
+ 之前是死的（0），现在复活了———— 用2表示；

不变两种情况：
+ 之前是活的（1），现在继续活着————不更改，用1表示；
+ 之前是死的（0），现在继续死的————不更改，用0表示；

**统计时，细胞状态为1 或者为 -1 都表示上一个状态这个细胞是活着的，活细胞数量+1；**

```cpp
// 定义新状态-1和2
class Solution {
public:
    void gameOfLife(vector<vector<int>>& board) {
        int col = board[0].size();
        int row = board.size();
        int neig[8][2] = {{-1,-1}, {-1,0}, {-1,1}, {0,-1}, {0,1}, {1,-1}, {1,0}, {1,1}};
        for(int i = 0; i < row; i++){
            for(int j = 0; j < col; j++){
                // 统计近邻的8个格子的活细胞数量
                int live_num = 0;
                for(auto& dir : neig){ 
                    int r = i + dir[0];
                    int c = j + dir[1];
                    if(r < row && r >= 0 && c >= 0 && c < col){
                        if(abs(board[r][c]) == 1)
                            live_num++;  
                    }                      
                }           

                if(board[i][j] == 1 && ( live_num < 2 || live_num > 3) )                   
                    board[i][j] = -1;
                if(board[i][j] == 0 && live_num == 3)
                    board[i][j] = 2;
            }
        }
        // 更新会0/1 两个状态
        for(int i = 0; i < row; i++){
            for(int j = 0; j < col; j++){
                if(board[i][j] <= 0)
                    board[i][j] = 0;
                else    
                    board[i][j] = 1;
            }
        }
    }
};
```

